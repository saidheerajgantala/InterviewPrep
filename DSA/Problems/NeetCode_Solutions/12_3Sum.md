# üìù 3Sum

## **Problem Statement**

* Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.
* Notice that the solution set must not contain duplicate triplets.
* Example:
  * Input: nums = [-1,0,1,2,-1,-4]
  * Output: [[-1,-1,2],[-1,0,1]]
  * Explanation: 
    * nums[0] + nums[2] + nums[4] = (-1) + 1 + (-1) = -1 + 1 - 1 = 0
    * nums[1] + nums[2] + nums[5] = 0 + 1 + (-4) = 1 - 4 = -3 (not a solution)
    * nums[0] + nums[3] + nums[5] = (-1) + 2 + (-4) = -1 + 2 - 4 = -3 (not a solution)
    * The distinct triplets are [-1,0,1] and [-1,-1,2].
    * Notice that the order of the output and the order of the triplets does not matter.
* Constraints:
  * 3 <= nums.length <= 3000
  * -10^5 <= nums[i] <= 10^5

---

## **Step 1: Thinking Process (Brute Force)**

* We need to find all unique triplets that sum to zero
* The most straightforward approach would be to check every possible triplet
* We can use three nested loops to iterate through all possible combinations
* For each triplet, we check if their sum is zero
* If it is, we add it to our result set, making sure to avoid duplicates
* To handle duplicates, we can sort each triplet before adding it to a set

---

## **Step 2: Flow Steps (Brute Force)**

1. Initialize an empty set to store unique triplets
2. For each index i from 0 to n-3:
   1. For each index j from i+1 to n-2:
      1. For each index k from j+1 to n-1:
         1. If nums[i] + nums[j] + nums[k] equals 0:
            1. Create a sorted triplet [nums[i], nums[j], nums[k]]
            2. Add the triplet to the set
3. Convert the set to a list and return it

---

## **Step 3: Brute Force Implementation (Code)**

```python
def threeSum(nums):
    n = len(nums)
    result = set()
    
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if nums[i] + nums[j] + nums[k] == 0:
                    # Sort to handle duplicates
                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))
                    result.add(triplet)
    
    # Convert set of tuples back to list of lists
    return [list(triplet) for triplet in result]
```

---

## **Step 4: Complexity Analysis (Brute Force)**

* Time Complexity: O(n¬≥) where n is the length of the array. We have three nested loops.
* Space Complexity: O(n) for storing the result.
* This approach is very inefficient for large arrays and will likely result in a time limit exceeded error.

---

## **Step 5: Visualizing Redundant Computation**

* For array [-1,0,1,2,-1,-4]:
  * We check all possible triplets (20 combinations for n=6)
  * Many triplets are checked that clearly won't sum to zero
  * We're not leveraging any properties of the problem to reduce the search space
  * For example, if we've already determined that nums[i] + nums[j] is very large, we might not need to check all possible values for nums[k]

---

## **Why are we using this algorithm?**

* For optimization, we'll use a Two-Pointer algorithm combined with sorting.
* The property that matches this problem is the ability to efficiently find pairs that sum to a target value in a sorted array.
* By sorting the array and using a two-pointer approach for each fixed element, we can reduce the time complexity.
* Alternatives like hash-based approaches would work but would be more complex for handling duplicates.
* Precondition: We need to sort the array first.

---

## **Algo optimization**

### **Step 1: Thinking Process (Optimized)**

* We can optimize by reducing the 3Sum problem to multiple 2Sum problems
* First, we sort the array to help with duplicate handling and to use the two-pointer technique
* For each element nums[i], we need to find pairs (nums[j], nums[k]) such that nums[j] + nums[k] = -nums[i]
* We can use the two-pointer technique from the Two Sum II problem to find these pairs efficiently
* To avoid duplicates, we skip duplicate values of nums[i], nums[j], and nums[k]

### **Step 2: Flow Steps (Optimized)**

1. Sort the array
2. Initialize an empty list to store the result
3. For each index i from 0 to n-3:
   1. If i > 0 and nums[i] == nums[i-1], continue (skip duplicates)
   2. Set target = -nums[i]
   3. Use two pointers (left = i+1, right = n-1) to find pairs that sum to target:
      1. While left < right:
         1. If nums[left] + nums[right] == target:
            1. Add [nums[i], nums[left], nums[right]] to the result
            2. Increment left and decrement right
            3. Skip duplicates for both left and right
         2. If nums[left] + nums[right] < target, increment left
         3. If nums[left] + nums[right] > target, decrement right
4. Return the result

### **Step 3: Implementation (Optimized)**

```python
def threeSum(nums):
    n = len(nums)
    result = []
    
    # Sort the array
    nums.sort()
    
    for i in range(n):
        # Skip duplicates for the first element
        if i > 0 and nums[i] == nums[i-1]:
            continue
        
        # Use two-pointer technique for the remaining array
        left, right = i + 1, n - 1
        target = -nums[i]
        
        while left < right:
            if nums[left] + nums[right] == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Move both pointers
                left += 1
                right -= 1
                
                # Skip duplicates for the second element
                while left < right and nums[left] == nums[left-1]:
                    left += 1
                
                # Skip duplicates for the third element
                while left < right and nums[right] == nums[right+1]:
                    right -= 1
            
            elif nums[left] + nums[right] < target:
                left += 1
            else:
                right -= 1
    
    return result
```

### **Step 4: Complexity Analysis (Optimized)**

* Time Complexity: O(n¬≤) where n is the length of the array.
  * Sorting takes O(n log n)
  * The nested loops take O(n¬≤)
* Space Complexity: O(1) excluding the space for the output.
* This is much more efficient than the brute force approach, especially for large arrays.

### **Step 5: Visualizing Computation (Optimized)**

* For array [-1,0,1,2,-1,-4]:
  * After sorting: [-4,-1,-1,0,1,2]
  * For i=0 (nums[i]=-4), target=4:
    * left=1 (-1), right=5 (2) ‚Üí sum=1 < target, so left++
    * left=2 (-1), right=5 (2) ‚Üí sum=1 < target, so left++
    * left=3 (0), right=5 (2) ‚Üí sum=2 < target, so left++
    * left=4 (1), right=5 (2) ‚Üí sum=3 < target, so left++
    * left=5 (2), right=5 (2) ‚Üí left=right, so we're done with this i
  * For i=1 (nums[i]=-1), target=1:
    * left=2 (-1), right=5 (2) ‚Üí sum=1 == target, add [-1,-1,2] to result
    * left=3, right=4 ‚Üí nums[left]=0, nums[right]=1, sum=1 == target, add [-1,0,1] to result
    * left=4, right=3 ‚Üí left > right, so we're done with this i
  * For i=2 (nums[i]=-1), skip because it's a duplicate
  * For i=3 (nums[i]=0), target=0:
    * left=4 (1), right=5 (2) ‚Üí sum=3 > target, so right--
    * left=4 (1), right=4 (1) ‚Üí left=right, so we're done with this i
  * For i=4 and i=5, we're done because i+2 > n
  * Result: [[-1,-1,2],[-1,0,1]]
* We're efficiently finding triplets by reducing the problem to multiple 2Sum problems.

### **Complexity Summary**

| Approach | Time | Space | Notes |
|---|---|---|---|
| Brute Force | O(n¬≥) | O(n) | Checks all possible triplets |
| Optimized (Algorithm: Two-Pointer) | O(n¬≤) | O(1) | Reduces to multiple 2Sum problems |

---

## **Final Takeaways**

* Reducing the 3Sum problem to multiple 2Sum problems allows us to leverage the efficient two-pointer technique.
* Sorting the array helps with both duplicate handling and enabling the two-pointer approach.
* The key insight is to fix one element and then find pairs that sum to its negation.
* This pattern of reducing a k-sum problem to a (k-1)-sum problem is a common technique.

---

## **Real-life Analogy**

* Imagine you're a chef trying to create a dish with three ingredients that balance each other perfectly (sum to zero). The brute force approach would be like trying every possible combination of three ingredients from your pantry. The optimized approach is like organizing your ingredients by flavor intensity, then for each ingredient, efficiently finding pairs of other ingredients that balance it out - if the current pair is too strong, you pick a milder ingredient; if too mild, you pick a stronger one.

---

## **Summary**

* We solved the "3Sum" problem by first considering a brute force approach that checks all possible triplets, resulting in O(n¬≥) time complexity. We then optimized by sorting the array and using a two-pointer technique to reduce the problem to multiple 2Sum problems, achieving O(n¬≤) time complexity. This demonstrates how breaking down a complex problem into simpler subproblems and leveraging efficient algorithms for those subproblems can significantly improve overall efficiency. 