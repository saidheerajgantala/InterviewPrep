# Algorithm Reference

## Name
- Category: [Greedy | DP | Graph | Search | Geometry | Other]
- Summary: one-liner of the core idea.

## Preconditions / Assumptions
- Data/domain constraints (sorted? distinct? non-negative weights? DAG?).
- Model limits (integer ranges, recursion limits, memory budget).

## Properties
- Stability (sorting), in-place, deterministic/randomized, online, completeness, optimality conditions.

## Complexity (per variant)
| Variant | Best | Average | Worst | Space | Notes |
|---|---|---|---|---|---|
| Baseline |  |  |  |  |  |
| Optimized-X |  |  |  |  |  |

## When to Use / When to Avoid
- Use if: ...
- Avoid if: ...
- Typical constraints where it’s optimal: N, M ranges, memory.

## Correctness (Proof Sketch)
- Invariant / exchange argument / cut property / induction.
- Termination argument.
- Edge-case handling rationale.

## Pseudocode (canonical)
```pseudo
function algorithm(input):
    # invariant: ...
    initialize ...
    while condition:
        ...
    return result
```

## Implementation Notes
- Data structures chosen and why; complexity impact.
- Pitfalls: off-by-one, overflow, recursion depth, tie-breaking, precision.

## Edge-case Checklist
- Empty/singleton, duplicates/ties, negative values, disconnected graphs, cycles, multi-edges, overflow.

## Examples
- Minimal example with I/O.
- Tricky counterexample and how it’s handled.

## Variants / Alternatives
- Closely related variants and trade-offs.
- Alternatives that beat it under specific constraints.

## References
- Book/page, paper, reputable articles. 